#!/bin/bash
banner='
███╗   ███╗███████╗███╗   ██╗██████╗ ██╗██╗  ██╗
████╗ ████║██╔════╝████╗  ██║██╔══██╗██║╚██╗██╔╝
██╔████╔██║█████╗  ██╔██╗ ██║██║  ██║██║ ╚███╔╝ 
██║╚██╔╝██║██╔══╝  ██║╚██╗██║██║  ██║██║ ██╔██╗ 
██║ ╚═╝ ██║███████╗██║ ╚████║██████╔╝██║██╔╝ ██╗
╚═╝     ╚═╝╚══════╝╚═╝  ╚═══╝╚═════╝ ╚═╝╚═╝  ╚═╝'

title="Welcome to the Mendix for Private Cloud Configuration Script"
echo "${banner}"
echo "${title}"
echo

NAMESPACE="$1"
CLUSTER_UUID="$2"
CLUSTER_SECRET="$3"

if [ -z "${NAMESPACE}" ] || [ -z "${CLUSTER_UUID}" ] || [ -z "${CLUSTER_SECRET}" ]; then
    printf "Failed to run script as one or more parameters were not provided\n"
    printf "Required args: <NAMESPACE> <CLUSTER_ID> <CLUSTER_SECRET>"
    exit 1
fi

PROVISIONER_REPOSITORY="docker-local.artifactory.rnd.mendix.com/private-cloud/storage-provisioner"
CLOUD_PORTAL_URL="https://privatecloud-test.mendixcloud.com"
kubectl_patch="kubectl -n ${NAMESPACE} patch "
kubectl_apply_eof="kubectl -n ${NAMESPACE} apply -f -"
kubectl_delete="kubectl -n ${NAMESPACE} delete"
kubectl_set="kubectl -n ${NAMESPACE} set"
kubectl_annotate="kubectl -n ${NAMESPACE} annotate"
kubectl_create="kubectl -n ${NAMESPACE} create"

# function to configure the AWS ECR Registry
awsECRConfig() {
  ecrUrlPrompt="What's the hostname of the ECR registry?"
  ecrNamePrompt="What's the name of the registry?"
  awsAccessKeyPrompt="What's the access key ID of your AWS account?"
  awsSecretKeyPrompt="What's the secret access key of your AWS account?"
  awsRegionPrompt="What's the region of you AWS account?"

  echo
  echo "$ecrUrlPrompt"
  read -p 'ECR_HOSTNAME: ' ECR_HOSTNAME
  echo "$ecrNamePrompt"
  read -p 'ECR_NAME: ' ECR_NAME
  echo "$awsRegionPrompt"
  read -p 'AWS_REGION: ' AWS_REGION
  echo "$awsAccessKeyPrompt"
  read -p 'AWS_ACCESS_KEY_ID: ' AWS_ACCESS_KEY_ID
  echo "$awsSecretKeyPrompt"
  read -sp 'AWS_SECRET_ACCESS_KEY: ' AWS_SECRET_ACCESS_KEY

  AWS_CREDENTIALS=$(
cat <<EOF
[default]\nregion=${AWS_REGION}\naws_access_key_id=${AWS_ACCESS_KEY_ID}\naws_secret_access_key=${AWS_SECRET_ACCESS_KEY}
EOF
  )

  ECR_PATCH=$(
cat <<EOF

{
  "spec": {
    "registry": {
      "type": "ecr",
      "pushURL": "${ECR_HOSTNAME}",
      "pullURL": "${ECR_HOSTNAME}",
      "imageNameTemplate": "${ECR_NAME}:{{.Name}}",
      "credentials": "mendix-registry-ecr-secret"
    }
  }
}

EOF
  )

# ECR secret
cat <<EOF | $kubectl_apply_eof
apiVersion: v1
kind: Secret
metadata:
  name: mendix-registry-ecr-secret
type: Opaque
stringData:
    credentials: "${AWS_CREDENTIALS}"
EOF

  #remove annotation
  $kubectl_annotate secret mendix-registry-ecr-secret kubectl.kubernetes.io/last-applied-configuration-

  $kubectl_patch operatorconfiguration mendix-operator-configuration --type=merge -p "${ECR_PATCH}"
}

# function to configure the Openshift3 Registry
openshift3RegistryConfig() {
  os3RegistryPullURLPrompt="What's the pull URL of the registry?"
  os3RegistryPushURLPrompt="What's the push URL of the registry?"

  echo
  echo "$os3RegistryPullURLPrompt"
  read -p 'OS3_PULL_URL: ' OS3_PULL_URL
  echo "$os3RegistryPushURLPrompt"
  read -p 'OS3_PUSH_URL: ' OS3_PUSH_URL

  OS3_REGISTRY_PATCH=$(
cat <<EOF

{
  "spec": {
    "registry": {
      "type": "openshift", 
      "pushURL": "${OS3_PUSH_URL}",
      "pullURL": "${OS3_PULL_URL}",
      "imageNameTemplate": "${NAMESPACE}/{{.Name}}"
    }
  }
}

EOF
  )

  $kubectl_patch operatorconfiguration mendix-operator-configuration --type=merge -p "${OS3_REGISTRY_PATCH}"
}

# function to configure the Openshift4 Registry
openshift4RegistryConfig() {

  OS4_REGISTRY_PATCH=$(
cat <<EOF

{
  "spec": {
    "registry": {
      "type": "openshift", 
      "pushURL": "image-registry.openshift-image-registry.svc:5000",
      "pullURL": "image-registry.openshift-image-registry.svc:5000",
      "imageNameTemplate": "${NAMESPACE}/{{.Name}}"
    }
  }
}

EOF
  )

  $kubectl_patch operatorconfiguration mendix-operator-configuration --type=merge -p "${OS4_REGISTRY_PATCH}"

}

# function to configure the generic registry without authentication
genericRegistryNoAuthConfig() {
  genericRegistryNoAuthPullURLPrompt="What's the pull URL of the registry?"
  genericRegistryNoAuthPushURLPrompt="What's the push URL of the registry?"
  genericRegistryNoAuthNamePrompt="What's the name of the registry?"
  genericRegistryNoAuthAddToServiceAccountPrompt="Add the credentials to imagePullSecrets in the default ServiceAccount?"
  genericRegistryNoAuthAddToServiceAccountOptions=("Yes" "No")

  echo
  echo "$genericRegistryNoAuthPullURLPrompt"
  read -p 'GENERIC_REGISTRY_NO_AUTH_PULL_URL: ' GENERIC_REGISTRY_NO_AUTH_PULL_URL
  echo "$genericRegistryNoAuthPushURLPrompt"
  read -p 'GENERIC_REGISTRY_NO_AUTH_PUSH_URL: ' GENERIC_REGISTRY_NO_AUTH_PUSH_URL
  echo "$genericRegistryNoAuthNamePrompt"
  read -p 'GENERIC_REGISTRY_NO_AUTH_NAME: ' GENERIC_REGISTRY_NO_AUTH_NAME

  isAddToServiceAccountRegistryNoAuth=""
  echo "$genericRegistryNoAuthAddToServiceAccountPrompt"
  select opt in "${genericRegistryNoAuthAddToServiceAccountOptions[@]}"; do
    case "$REPLY" in
    1)
      echo "You picked $opt. Credentials will be added to imagePullSecrets in the default ServiceAccount"
      #yes
      isAddToServiceAccountRegistryNoAuth=true
      break
      ;;
    2)
      echo "You picked $opt."
      #no
      break
      ;;
    *)
      echo "Invalid option. Try another one."
      continue
      ;;
    esac
  done

  GENERIC_NO_AUTH_REGISTRY_PATCH=$(
cat <<EOF

{
  "spec": {
    "registry": {
      "type": "dockercfg",
      "pushURL": "${GENERIC_REGISTRY_NO_AUTH_PUSH_URL}",
      "pullURL": "${GENERIC_REGISTRY_NO_AUTH_PULL_URL}",
      "imageNameTemplate": "${GENERIC_REGISTRY_NO_AUTH_NAME}:{{.Name}}",
      "credentials": "mendix-generic-registry-secret"
    }
  }
}

EOF
  )
  
  # Create docker registry secret (dockerconfig)
  cat <<EOF | $kubectl_apply_eof
apiVersion: v1
kind: Secret
metadata:
  name: mendix-generic-registry-secret
stringData:
    .dockerconfigjson: |-
      {}
type: kubernetes.io/dockerconfigjson
EOF

  if [ "$isAddToServiceAccountRegistryNoAuth" = true ]; then
    $kubectl_patch serviceaccount default -p '{"imagePullSecrets": [{"name": "mendix-generic-registry-secret"}]}'
  fi

  #remove annotation
  $kubectl_annotate secret mendix-generic-registry-secret kubectl.kubernetes.io/last-applied-configuration-

  $kubectl_patch operatorconfiguration mendix-operator-configuration --type=merge -p "${GENERIC_NO_AUTH_REGISTRY_PATCH}"
}

# function to configure the generic registry with authentication
genericRegistryAuthConfig() {
  genericRegistryAuthPullURLPrompt="What's the pull URL of the registry?"
  genericRegistryAuthPushURLPrompt="What's the push URL of the registry?"
  genericRegistryAuthNamePrompt="What's the name of the registry?"
  genericRegistryAuthUserPrompt="What's the user for the registry?"
  genericRegistryAuthPasswordPrompt="What's the password of the registry?"
  genericRegistryAuthAddToServiceAccountPrompt="Add the credentials to imagePullSecrets in the default ServiceAccount?"
  genericRegistryAuthAddToServiceAccountOptions=("Yes" "No")

  echo
  echo "$genericRegistryAuthPullURLPrompt"
  read -p 'GENERIC_REGISTRY_AUTH_PULL_URL: ' GENERIC_REGISTRY_AUTH_PULL_URL
  echo "$genericRegistryAuthPushURLPrompt"
  read -p 'GENERIC_REGISTRY_AUTH_PUSH_URL: ' GENERIC_REGISTRY_AUTH_PUSH_URL
  echo "$genericRegistryAuthNamePrompt"
  read -p 'GENERIC_REGISTRY_AUTH_NAME: ' GENERIC_REGISTRY_AUTH_NAME
  echo "$genericRegistryAuthUserPrompt"
  read -p 'GENERIC_REGISTRY_AUTH_USER: ' GENERIC_REGISTRY_AUTH_USER
  echo "$genericRegistryAuthPasswordPrompt"
  read -sp 'GENERIC_REGISTRY_AUTH_PASSWORD: ' GENERIC_REGISTRY_AUTH_PASSWORD

  isAddToServiceAccountRegistryAuth=""
  echo "$genericRegistryAuthAddToServiceAccountPrompt"
  select opt in "${genericRegistryAuthAddToServiceAccountOptions[@]}"; do
    case "$REPLY" in
    1)
      echo "You picked $opt. Credentials will be added to imagePullSecrets in the default ServiceAccount"
      #yes
      isAddToServiceAccountRegistryAuth=true
      break
      ;;
    2)
      echo "You picked $opt."
      #no
      break
      ;;
    *)
      echo "Invalid option. Try another one."
      continue
      ;;
    esac
  done

  GENERIC_AUTH_REGISTRY_PATCH=$(
cat <<EOF

{
  "spec": {
    "registry": {
      "type": "dockercfg",
      "pushURL": "${GENERIC_REGISTRY_AUTH_PUSH_URL}",
      "pullURL": "${GENERIC_REGISTRY_AUTH_PULL_URL}",
      "imageNameTemplate": "${GENERIC_REGISTRY_AUTH_NAME}:{{.Name}}",
      "credentials": "mendix-generic-registry-secret"
    }
  }
}

EOF
  )

  # Create docker registry secret (dockerconfig)
  GENERIC_REGISTRY_AUTH_SERVER="${GENERIC_REGISTRY_AUTH_PUSH_URL}"

  if [[ $GENERIC_REGISTRY_AUTH_PUSH_URL == "index.docker.io" ]]; then
    GENERIC_REGISTRY_AUTH_SERVER="https://index.docker.io/v1/"
  fi

  #secret
 $kubectl_create secret docker-registry mendix-generic-registry-secret \
    --docker-server="${GENERIC_REGISTRY_AUTH_SERVER}" \
	--docker-username="${GENERIC_REGISTRY_AUTH_USER}" \
	--docker-password="${GENERIC_REGISTRY_AUTH_PASSWORD}" \
	--dry-run -o yaml | kubectl apply -f -

  if [ "$isAddToServiceAccountRegistryAuth" = true ]; then
    $kubectl_patch serviceaccount default -p '{"imagePullSecrets": [{"name": "mendix-generic-registry-secret"}]}'
  fi

  #remove annotation
  $kubectl_annotate secret mendix-generic-registry-secret kubectl.kubernetes.io/last-applied-configuration-
	
  $kubectl_patch operatorconfiguration mendix-operator-configuration --type=merge -p "${GENERIC_AUTH_REGISTRY_PATCH}"
}

# function to use existing docker-registry secret
existingDockerConfig() {
  existingDockerConfigRegistrySecretNamePrompt="What's the existing docker-registry secret name?"
  existingDockerRegistryPullUrlPrompt="What's the pull URL of the registry?"
  existingDockerRegistryPushUrlPrompt="What's the push URL of the registry?"
  existingDockerConfigRegistryNamePrompt="What's the name of the registry?"

  echo "$existingDockerRegistryPullUrlPrompt"
  read -p 'EXISTING_DOCKER_CONFIG_REGISTRY_PULL_URL: ' EXISTING_DOCKER_CONFIG_REGISTRY_PULL_URL
  echo "$existingDockerRegistryPushUrlPrompt"
  read -p 'EXISTING_DOCKER_CONFIG_REGISTRY_PUSH_URL: ' EXISTING_DOCKER_CONFIG_REGISTRY_PUSH_URL
  echo "$existingDockerConfigRegistryNamePrompt"
  read -p 'EXISTING_DOCKER_CONFIG_REGISTRY_NAME: ' EXISTING_DOCKER_CONFIG_REGISTRY_NAME
  echo "$existingDockerConfigRegistrySecretNamePrompt"
  read -p 'EXISTING_DOCKER_CONFIG_REGISTRY_SECRET_NAME: ' EXISTING_DOCKER_CONFIG_REGISTRY_SECRET_NAME

  USE_EXISTING_DOCKER_REGISTRY_SECRET_PATCH=$(
cat <<EOF

{
  "spec": {
    "registry": {
      "type": "dockercfg",
      "pushURL": "${EXISTING_DOCKER_CONFIG_REGISTRY_PUSH_URL}",
      "pullURL": "${EXISTING_DOCKER_CONFIG_REGISTRY_PULL_URL}",
      "imageNameTemplate": "${EXISTING_DOCKER_CONFIG_REGISTRY_NAME}:{{.Name}}",
      "credentials": "${EXISTING_DOCKER_CONFIG_REGISTRY_SECRET_NAME}"
    }
  }
}

EOF
  )

  $kubectl_patch operatorconfiguration mendix-operator-configuration --type=merge -p "${USE_EXISTING_DOCKER_REGISTRY_SECRET_PATCH}"
}

addPlanToPortal() {
  resource=$1
  planName=$2
  planType=$3

  if [ ! -z $CLUSTER_UUID ] && [ ! -z $CLUSTER_SECRET ]; then

    RESPONSE_CODE=$(curl -o /dev/null -Isw "%{RESPONSE_CODE}" -u $CLUSTER_UUID:$CLUSTER_SECRET -X PUT "$CLOUD_PORTAL_URL"/rest/plansconfiguration/v1/plans/${resource}/${CLUSTER_UUID}/${planName}?planType=${planType})
    if [ "${RESPONSE_CODE}" = "200" ]; then
      printf "Plan successfully created on Portal."
    else
      printf "Plan creation on the Portal failed."
      exit 1
    fi

  fi
}

# function to configure the POSTGRESQL database
postgresConfig() {
  postgresNamePrompt="What's the name of the plan?"
  postgresHostPrompt="What's the host of the database?"
  postgresPortPrompt="What's the port of the database?"
  postgresDbNamePrompt="What's the database name?"
  postgresUserPrompt="What's the user of the database?"
  postgresPasswordPrompt="What's the password of the database?"

  echo
  echo "$postgresNamePrompt"
  read -p 'POSTGRES_PLAN_NAME: ' POSTGRES_PLAN_NAME
  echo "$postgresHostPrompt"
  read -p 'POSTGRES_HOST: ' POSTGRES_HOST
  echo "$postgresPortPrompt"
  read -p 'POSTGRES_PORT: ' POSTGRES_PORT
  echo "$postgresDbNamePrompt"
  read -p 'POSTGRES_DBNAME: ' POSTGRES_DBNAME
  echo "$postgresUserPrompt"
  read -p 'POSTGRES_USER: ' POSTGRES_USER
  echo "$postgresPasswordPrompt"
  read -sp 'POSTGRES_PASSWORD: ' POSTGRES_PASSWORD

  #secret
  cat <<EOF | $kubectl_apply_eof
apiVersion: v1
kind: Secret
metadata:
  name: mendix-database-${POSTGRES_PLAN_NAME}-secret
type: Opaque
stringData:
    PGHOST: "${POSTGRES_HOST}"
    PGPORT: "${POSTGRES_PORT}"
    PGDATABASE: "${POSTGRES_DBNAME}"
    PGUSER: "${POSTGRES_USER}"
    PGPASSWORD: "${POSTGRES_PASSWORD}"
EOF

  #remove annotation
  $kubectl_annotate secret mendix-database-${POSTGRES_PLAN_NAME}-secret kubectl.kubernetes.io/last-applied-configuration-

cat <<EOF | $kubectl_apply_eof

apiVersion: privatecloud.mendix.com/v1alpha1
kind: StoragePlan
metadata:
    name: "${POSTGRES_PLAN_NAME}"
    labels:
        privatecloud.mendix.com/storage-type: database
        privatecloud.mendix.com/storage-class: ""
        privatecloud.mendix.com/storage-plan: "${POSTGRES_PLAN_NAME}"
spec:
    type: on-demand
    create:
        image: ${PROVISIONER_REPOSITORY}:postgres96-rhel
        resources:
            requests:
                memory: "64Mi"
                cpu: "100m"
            limits:
                memory: "64Mi"
                cpu: "500m"
        command: ["create"]
        credentialsSecretName: mendix-database-${POSTGRES_PLAN_NAME}-secret
        serviceAccountName: mendix-storage-provisioner
        instanceNameTemplate: "mendix-{{.Name}}-{{.UUID}}"
    delete:
        image: ${PROVISIONER_REPOSITORY}:postgres96-rhel
        resources:
            requests:
                memory: "64Mi"
                cpu: "100m"
            limits:
                memory: "64Mi"
                cpu: "500m"
        command: ["delete"]
        credentialsSecretName: mendix-database-${POSTGRES_PLAN_NAME}-secret

EOF

  addPlanToPortal "database" ${POSTGRES_PLAN_NAME} "OnDemand"
}

# function to configure the Ephemeral database
ephemeralDatabaseConfig() {
  cat <<EOF | $kubectl_apply_eof

apiVersion: privatecloud.mendix.com/v1alpha1
kind: StoragePlan
metadata:
  name: database-ephemeral
  labels:
    privatecloud.mendix.com/storage-type: database
    privatecloud.mendix.com/storage-class: ""
    privatecloud.mendix.com/storage-plan: ephemeral
spec:
  type: on-demand
  create:
    image: ${PROVISIONER_REPOSITORY}:basic-rhel
    resources:
      requests:
        memory: "64Mi"
        cpu: "100m"
      limits:
        memory: "64Mi"
        cpu: "500m"
    command: ["create"]
    args: ['--from-value={"DatabaseType":"HSQLDB","DatabaseName":"db"}']
    serviceAccountName: mendix-storage-provisioner
    instanceNameTemplate: "mendix-{{.Name}}-{{.UUID}}"
  delete:
    image: ${PROVISIONER_REPOSITORY}:basic-rhel
    resources:
      requests:
        memory: "64Mi"
        cpu: "100m"
      limits:
        memory: "64Mi"
        cpu: "500m"
    command: []
    args: []

EOF

  addPlanToPortal "database" "ephemeral" "OnDemand"
}

# function to configure the SQLSERVER database
sqlserverConfig() {
  sqlserverNamePrompt="What's the name of the plan?"
  sqlserverHostPrompt="What's the host of the database?"
  sqlserverPortPrompt="What's the port of the database?"
  sqlserverUserPrompt="What's the user of the database?"
  sqlserverPasswordPrompt="What's the password of the database?"

  echo
  echo "$sqlserverNamePrompt"
  read -p 'MSSQL_SERVER_PLAN_NAME: ' MSSQL_SERVER_PLAN_NAME
  echo "$sqlserverHostPrompt"
  read -p 'MSSQL_SERVER_HOST: ' MSSQL_SERVER_HOST
  echo "$sqlserverPortPrompt"
  read -p 'MSSQL_SERVER_PORT: ' MSSQL_SERVER_PORT
  echo "$sqlserverUserPrompt"
  read -p 'MSSQL_SERVER_USER: ' MSSQL_SERVER_USER
  echo "$sqlserverPasswordPrompt"
  read -sp 'MSSQL_SERVER_PASSWORD: ' MSSQL_SERVER_PASSWORD

  isAzureSqlQuestionPrompt="Is this an Azure SQL database? "
  isAzureSqlOptions=("Yes" "No")
  AZURE_PLAN_ARGS=""
  
  echo
  echo "$isAzureSqlQuestionPrompt"
  select opt in "${isAzureSqlOptions[@]}"; do
    case "$REPLY" in
    1)
      echo "You picked $opt."
      #yes
      azuresqlConfig
      break
      ;;
    2)
      echo "You picked $opt. No azure sql configuration is created."
      #no
      break
      ;;
    *)
      echo "Invalid option. Try another one."
      continue
      ;;
    esac
  done

  #secret
  cat <<EOF | $kubectl_apply_eof
apiVersion: v1
kind: Secret
metadata:
  name: mendix-database-${MSSQL_SERVER_PLAN_NAME}-secret
type: Opaque
stringData:
    MSSQL_SERVER_HOST: "${MSSQL_SERVER_HOST}"
    MSSQL_SERVER_PORT: "${MSSQL_SERVER_PORT}"
    MSSQL_SERVER_USER: "${MSSQL_SERVER_USER}"
    MSSQL_SERVER_PASSWORD: "${MSSQL_SERVER_PASSWORD}"
EOF

  #remove annotation
  $kubectl_annotate secret mendix-database-${MSSQL_SERVER_PLAN_NAME}-secret kubectl.kubernetes.io/last-applied-configuration-

cat <<EOF | $kubectl_apply_eof

apiVersion: privatecloud.mendix.com/v1alpha1
kind: StoragePlan
metadata:
    name: "${MSSQL_SERVER_PLAN_NAME}"
    labels:
        privatecloud.mendix.com/storage-type: database
        privatecloud.mendix.com/storage-class: ""
        privatecloud.mendix.com/storage-plan: "${MSSQL_SERVER_PLAN_NAME}"
spec:
    type: on-demand
    create:
        args: [ ${AZURE_PLAN_ARGS} ]
        image: ${PROVISIONER_REPOSITORY}:sqlserver2017-rhel
        resources:
            requests:
                memory: "64Mi"
                cpu: "100m"
            limits:
                memory: "128Mi"
                cpu: "500m"
        command: ["create"]
        credentialsSecretName: mendix-database-${MSSQL_SERVER_PLAN_NAME}-secret
        serviceAccountName: mendix-storage-provisioner
        instanceNameTemplate: "mendix-{{.Name}}-{{.UUID}}"
    delete:
        image: ${PROVISIONER_REPOSITORY}:sqlserver2017-rhel
        resources:
            requests:
                memory: "64Mi"
                cpu: "100m"
            limits:
                memory: "128Mi"
                cpu: "500m"
        command: ["delete"]
        credentialsSecretName: mendix-database-${MSSQL_SERVER_PLAN_NAME}-secret

EOF

  addPlanToPortal "database" ${MSSQL_SERVER_PLAN_NAME} "OnDemand"
}

## Extra Azure SQL
azuresqlConfig() {
	azuresqlElasticPoolQuestionPrompt="What's the name of the Elastic Pool? (leave empty to not use an elastic pool)"
	azuresqlDatabaseEditionQuestionPrompt="What's the database edition (tier)? (e.g. GeneralPurpose, leave empty for default)"
	azuresqlServiceObjectiveToUseQuestionPrompt="What's the database Service Objective? (e.g. GP_S_Gen5_1, leave empty for default)"
	azuresqlDatabaseMaxSizeQuestionPrompt="What's the database maximum size? (e.g. 2 GB, leave empty for default)"
	azureDocumentation='https://docs.microsoft.com/en-us/sql/t-sql/statements/create-database-transact-sql?view=azuresqldb-current#create-a-database'

	echo
	echo "Configuring azure sql. Please check documentation for more information: "
	echo -e "\e]8;;$azureDocumentation\a$azureDocumentation\e]8;;\a"
	
	echo
	echo
	echo "$azuresqlElasticPoolQuestionPrompt"
	read -p 'ELASTIC_POOL: ' AZURE_SQL_ARG_ELASTIC_POOL

	if [ ! -z "${AZURE_SQL_ARG_ELASTIC_POOL}" ]; then
		AZURE_PLAN_ARGS="\"--azure-sql-elasticpool=${AZURE_SQL_ARG_ELASTIC_POOL}\""
	else
		echo "$azuresqlDatabaseEditionQuestionPrompt"
		read -p 'EDITION: ' AZURE_SQL_ARG_DATABASE_EDITION
		if [ ! -z "${AZURE_SQL_ARG_DATABASE_EDITION}" ]; then
			AZURE_PLAN_ARGS="\"--azure-sql-edition=${AZURE_SQL_ARG_DATABASE_EDITION}\""
		fi
	
		echo "$azuresqlServiceObjectiveToUseQuestionPrompt"
		read -p 'SERVICE_OBJECTIVE: ' AZURE_SQL_ARG_SERVICE_OBJECTIVE
		if [ ! -z "${AZURE_SQL_ARG_SERVICE_OBJECTIVE}" ]; then
			if [ ! -z "${AZURE_PLAN_ARGS}" ]; then
				AZURE_PLAN_ARGS="${AZURE_PLAN_ARGS}, "
			fi
			AZURE_PLAN_ARGS="${AZURE_PLAN_ARGS}\"--azure-sql-serviceobjective=${AZURE_SQL_ARG_SERVICE_OBJECTIVE}\""
		fi
	
		echo "$azuresqlDatabaseMaxSizeQuestionPrompt"
		read -p 'MAXSIZE: ' AZURE_SQL_ARG_MAX_SIZE
		if [ ! -z "${AZURE_SQL_ARG_MAX_SIZE}" ]; then
			if [ ! -z "${AZURE_PLAN_ARGS}" ]; then
				AZURE_PLAN_ARGS="${AZURE_PLAN_ARGS}, "
			fi
			AZURE_PLAN_ARGS="${AZURE_PLAN_ARGS}\"--azure-sql-maxsize=${AZURE_SQL_ARG_MAX_SIZE}\""
		fi
  	fi
}

# function to configure database with JDBC connection string
dedicatedJDBCConfig() {
  dedicatedJdbcPlanNamePrompt="What's the name of the plan?"
  dedicatedJdbcTypePrompt="What's the database type (DatabaseType)?"
  dedicatedJdbcHostPrompt="What's the host of the database (DatabaseHost)?"
  dedicatedJdbcDBNamePrompt="What's the database name (DatabaseName)?"
  dedicatedJdbcUrlPrompt="What's the JDBC URL of the database (DatabaseJdbcUrl)?"
  dedicatedJdbcUserPrompt="What's the user of the database (DatabaseUserName)?"
  dedicatedJdbcPasswordPrompt="What's the password of the database (DatabasePassword)?"
  databaseSettingsDocumentation='https://docs.mendix.com/refguide/custom-settings#4-database-settings'

  echo
  echo "Configuring database settings. Please check documentation for more information: "
  echo -e "\e]8;;$databaseSettingsDocumentation\a$databaseSettingsDocumentation\e]8;;\a"
  echo
  echo "$dedicatedJdbcPlanNamePrompt"
  read -p 'DEDICATED_JDBC_PLAN_NAME: ' DEDICATED_JDBC_PLAN_NAME
  echo "$dedicatedJdbcTypePrompt"
  read -p 'DEDICATED_JDBC_TYPE: ' DEDICATED_JDBC_TYPE
  echo "$dedicatedJdbcHostPrompt"
  read -p 'DEDICATED_JDBC_HOST: ' DEDICATED_JDBC_HOST
  echo "$dedicatedJdbcDBNamePrompt"
  read -p 'DEDICATED_JDBC_DBNAME: ' DEDICATED_JDBC_DBNAME
  echo "$dedicatedJdbcUrlPrompt"
  read -p 'DEDICATED_JDBC_URL: ' DEDICATED_JDBC_URL
  echo "$dedicatedJdbcUserPrompt"
  read -p 'DEDICATED_JDBC_USER: ' DEDICATED_JDBC_USER
  echo "$dedicatedJdbcPasswordPrompt"
  read -sp 'DEDICATED_JDBC_PASSWORD: ' DEDICATED_JDBC_PASSWORD
  echo

  #secret
  cat <<EOF | $kubectl_apply_eof
apiVersion: v1
kind: Secret
metadata:
  name: mendix-database-${DEDICATED_JDBC_PLAN_NAME}-secret
type: Opaque
stringData:
    config: |-
      {
        "DatabaseType":"${DEDICATED_JDBC_TYPE}",
        "DatabaseName": "${DEDICATED_JDBC_DBNAME}",
        "DatabaseUserName": "${DEDICATED_JDBC_USER}",
        "DatabasePassword": "${DEDICATED_JDBC_PASSWORD}",
        "DatabaseJdbcUrl": "${DEDICATED_JDBC_URL}",
        "DatabaseHost": "${DEDICATED_JDBC_HOST}"
      }
EOF

  #remove annotation
  $kubectl_annotate secret mendix-database-${DEDICATED_JDBC_PLAN_NAME}-secret kubectl.kubernetes.io/last-applied-configuration-

cat <<EOF | $kubectl_apply_eof

apiVersion: privatecloud.mendix.com/v1alpha1
kind: StoragePlan
metadata:
    name: "${DEDICATED_JDBC_PLAN_NAME}"
    labels:
        privatecloud.mendix.com/storage-type: database
        privatecloud.mendix.com/storage-class: ""
        privatecloud.mendix.com/storage-plan: "${DEDICATED_JDBC_PLAN_NAME}"
spec:
    type: dedicated
    create:
        args: [ "--from-secret" ]
        image: ${PROVISIONER_REPOSITORY}:basic-rhel
        resources:
            requests:
                memory: "64Mi"
                cpu: "100m"
            limits:
                memory: "64Mi"
                cpu: "500m"
        command: ["create"]
        credentialsSecretName: mendix-database-${DEDICATED_JDBC_PLAN_NAME}-secret
        serviceAccountName: mendix-storage-provisioner
        instanceNameTemplate: "mendix-{{.Name}}-{{.UUID}}"
    delete:
        image: ${PROVISIONER_REPOSITORY}:basic-rhel
        resources:
            requests:
                memory: "64Mi"
                cpu: "100m"
            limits:
                memory: "64Mi"
                cpu: "500m"
        command: ["delete"]
        credentialsSecretName: mendix-database-${DEDICATED_JDBC_PLAN_NAME}-secret

EOF

  addPlanToPortal "database" ${DEDICATED_JDBC_PLAN_NAME} "Dedicated"
}

# function to configure the MINIO storage
minioConfig() {
  minioNamePrompt="What's the name of the plan?"
  minioEndpointPrompt="What's the endpoint of the storage?"
  minioAccessKeyPrompt="What's the access key of the storage?"
  minioSecretKeyPrompt="What's the secret key of the storage?"
  echo
  echo "$minioNamePrompt"
  read -p 'MINIO_PLAN_NAME: ' MINIO_PLAN_NAME
  echo "$minioEndpointPrompt"
  read -p 'MINIO_ENDPOINT: ' MINIO_ENDPOINT
  echo "$minioAccessKeyPrompt"
  read -p 'MINIO_ACCESS_KEY: ' MINIO_ACCESS_KEY
  echo "$minioSecretKeyPrompt"
  read -sp 'MINIO_SECRET_KEY: ' MINIO_SECRET_KEY

  cat <<EOF | $kubectl_apply_eof

apiVersion: privatecloud.mendix.com/v1alpha1
kind: StoragePlan
metadata:
  name: "${MINIO_PLAN_NAME}"
  labels:
    privatecloud.mendix.com/storage-type: file
    privatecloud.mendix.com/storage-class: ""
    privatecloud.mendix.com/storage-plan: "${MINIO_PLAN_NAME}"
spec:
  type: on-demand
  create:
    image: ${PROVISIONER_REPOSITORY}:minio-rhel
    resources:
      requests:
        memory: "64Mi"
        cpu: "100m"
      limits:
        memory: "128Mi"
        cpu: "500m"
    command: ["create"]
    args: ["--region=eu-west-1"]
    credentialsSecretName: mendix-storage-${MINIO_PLAN_NAME}-secret
    serviceAccountName: mendix-storage-provisioner
    instanceNameTemplate: "mendix-{{.Name}}-{{.UUID}}"
  delete:
    image: ${PROVISIONER_REPOSITORY}:minio-rhel
    resources:
      requests:
        memory: "64Mi"
        cpu: "100m"
      limits:
        memory: "128Mi"
        cpu: "500m"
    command: ["delete"]
    args: []
    credentialsSecretName: mendix-storage-${MINIO_PLAN_NAME}-secret

EOF

  #secret
  cat <<EOF | $kubectl_apply_eof
apiVersion: v1
kind: Secret
metadata:
  name: mendix-storage-${MINIO_PLAN_NAME}-secret
type: Opaque
stringData:
    ENDPOINT: "${MINIO_ENDPOINT}"
    ACCESS_KEY: "${MINIO_ACCESS_KEY}"
    SECRET_KEY: "${MINIO_SECRET_KEY}"
EOF

  #remove annotation
  $kubectl_annotate secret mendix-storage-${MINIO_PLAN_NAME}-secret kubectl.kubernetes.io/last-applied-configuration-

  addPlanToPortal "storage" ${MINIO_PLAN_NAME} "OnDemand"
}

# function to configure the S3 storage (create on-demand)
s3Config() {
  s3NamePrompt="What's the name of the plan?"
  s3RegionPrompt="What's the region where to create S3 buckets? (e.g. eu-west-1)"
  s3AccessKeyPrompt="What's the access key of the storage?"
  s3SecretKeyPrompt="What's the secret key of the storage?"
  echo
  echo "$s3NamePrompt"
  read -p 'S3_PLAN_NAME: ' S3_PLAN_NAME
  echo "$s3RegionPrompt"
  read -p 'S3_REGION: ' S3_REGION
  echo "$s3AccessKeyPrompt"
  read -p 'S3_ACCESS_KEY: ' S3_ACCESS_KEY
  echo "$s3SecretKeyPrompt"
  read -sp 'S3_SECRET_KEY: ' S3_SECRET_KEY

  cat <<EOF | $kubectl_apply_eof

apiVersion: privatecloud.mendix.com/v1alpha1
kind: StoragePlan
metadata:
  name: "${S3_PLAN_NAME}"
  labels:
    privatecloud.mendix.com/storage-type: file
    privatecloud.mendix.com/storage-class: ""
    privatecloud.mendix.com/storage-plan: "${S3_PLAN_NAME}"
spec:
  type: on-demand
  create:
    image: ${PROVISIONER_REPOSITORY}:s3-rhel
    resources:
      requests:
        memory: "64Mi"
        cpu: "100m"
      limits:
        memory: "64Mi"
        cpu: "500m"
    command: ["create"]
    args: ["--region=${S3_REGION}"]
    credentialsSecretName: mendix-storage-${S3_PLAN_NAME}-secret
    serviceAccountName: mendix-storage-provisioner
    instanceNameTemplate: "mendix-{{.Name}}-{{.UUID}}"
  delete:
    image: ${PROVISIONER_REPOSITORY}:s3-rhel
    resources:
      requests:
        memory: "64Mi"
        cpu: "100m"
      limits:
        memory: "64Mi"
        cpu: "500m"
    command: ["delete"]
    args: []
    credentialsSecretName: mendix-storage-${S3_PLAN_NAME}-secret

EOF

  #secret
  cat <<EOF | $kubectl_apply_eof
apiVersion: v1
kind: Secret
metadata:
  name: mendix-storage-${S3_PLAN_NAME}-secret
type: Opaque
stringData:
    AWS_ACCESS_KEY_ID: "${S3_ACCESS_KEY}"
    AWS_SECRET_ACCESS_KEY: "${S3_SECRET_KEY}"
EOF

  #remove annotation
  $kubectl_annotate secret mendix-storage-${S3_PLAN_NAME}-secret kubectl.kubernetes.io/last-applied-configuration-

  addPlanToPortal "storage" ${S3_PLAN_NAME} "OnDemand"
}

# function to configure the S3 storage (existing bucket)
existingS3Config() {
  existingS3NamePrompt="What's the name of the plan?"
  existingS3EndpointPrompt="What's the s3 endpoint of the storage?"
  existingS3AccessKeyPrompt="What's the access key of the storage?"
  existingS3SecretKeyPrompt="What's the secret key of the storage?"
  s3SettingsDocumentation='https://docs.mendix.com/refguide/custom-settings#5-amazon-s3-storage-service-settings'
  existingS3DedicatedPrompt="Can this storage be used by multiple environments?"
  existingS3DedicatedOptions=("No" "Yes")

  echo
  echo "Configuring existing s3. Please check documentation for more information: "
  echo -e "\e]8;;$s3SettingsDocumentation\a$s3SettingsDocumentation\e]8;;\a"

  echo
  echo "$existingS3NamePrompt"
  read -p 'S3_PLAN_NAME: ' EXISTING_S3_PLAN_NAME
  echo "$existingS3EndpointPrompt"
  read -p 'com.mendix.storage.s3.EndPoint: ' EXISTING_S3_END_POINT
  echo "$existingS3AccessKeyPrompt"
  read -p 'com.mendix.storage.s3.AccessKeyId: ' EXISTING_S3_ACCESS_KEY
  echo "$existingS3SecretKeyPrompt"
  read -sp 'com.mendix.storage.s3.SecretAccessKey: ' EXISTING_S3_SECRET_KEY

  echo
  echo "$existingS3DedicatedPrompt"
  select opt in "${existingS3DedicatedOptions[@]}"; do
    case "$REPLY" in
    1)
      echo "You picked $opt."
      #can be shared = no
      EXISTING_S3_PLAN_TYPE=dedicated
      S3_PORTAL_PLAN_TYPE=Dedicated
      break
      ;;
    2)
      echo "You picked $opt."
      #can be shared = yes
      EXISTING_S3_PLAN_TYPE=on-demand
      S3_PORTAL_PLAN_TYPE=OnDemand
      break
      ;;
    *)
      echo "Invalid option. Try another one."
      continue
      ;;
    esac
  done

  cat <<EOF | $kubectl_apply_eof

apiVersion: privatecloud.mendix.com/v1alpha1
kind: StoragePlan
metadata:
    name: "${EXISTING_S3_PLAN_NAME}"
    labels:
        privatecloud.mendix.com/storage-type: file
        privatecloud.mendix.com/storage-class: ""
        privatecloud.mendix.com/storage-plan: "${EXISTING_S3_PLAN_NAME}"
spec:
    type: "${EXISTING_S3_PLAN_TYPE}"
    create:
        args: [ "--from-secret", "--template=com.mendix.storage.s3.BucketName" ]
        image: ${PROVISIONER_REPOSITORY}:basic-rhel
        resources:
            requests:
                memory: "64Mi"
                cpu: "100m"
            limits:
                memory: "128Mi"
                cpu: "500m"
        command: ["create"]
        credentialsSecretName: mendix-storage-${EXISTING_S3_PLAN_NAME}-secret
        serviceAccountName: mendix-storage-provisioner
        instanceNameTemplate: "mendix-{{.Name}}-{{.UUID}}"
    delete:
        image: ${PROVISIONER_REPOSITORY}:basic-rhel
        resources:
            requests:
                memory: "64Mi"
                cpu: "100m"
            limits:
                memory: "128Mi"
                cpu: "500m"
        command: ["delete"]
        credentialsSecretName: mendix-storage-${EXISTING_S3_PLAN_NAME}-secret

EOF

  #secret
  cat <<EOF | $kubectl_apply_eof

apiVersion: v1
kind: Secret
metadata:
  name: mendix-storage-${EXISTING_S3_PLAN_NAME}-secret
type: Opaque
stringData:
    config: |-
      {
        "com.mendix.storage.s3.EndPoint":"$EXISTING_S3_END_POINT",
        "com.mendix.storage.s3.AccessKeyId": "$EXISTING_S3_ACCESS_KEY",
        "com.mendix.storage.s3.SecretAccessKey": "$EXISTING_S3_SECRET_KEY",
        "com.mendix.storage.s3.BucketName": "{{ .SanitizedStorageInstanceName }}",
        "com.mendix.core.StorageService": "com.mendix.storage.s3"
      }

EOF

  #remove annotation
  $kubectl_annotate secret mendix-storage-${EXISTING_S3_PLAN_NAME}-secret kubectl.kubernetes.io/last-applied-configuration-

  addPlanToPortal "storage" ${EXISTING_S3_PLAN_NAME} ${S3_PORTAL_PLAN_TYPE}
}

# function to configure the existing Azure Blob container
azureBlobContainerConfig() {
  azureBlobNamePrompt="What's the name of the plan?"
  azureBlobAccountNamePrompt="What's Azure Blob Storage account name?"
  azureBlobAccountKeyPrompt="What's the Azure Blob Storage account key?"
  azureBlobContainerNamePrompt="What's Container name?"
  azureBlobDedicatedPrompt="Can this Container be used by multiple environments?"
  azureBlobDedicatedOptions=("No" "Yes")
  echo
  echo "$azureBlobNamePrompt"
  read -p 'EXISTING_AZURE_CONTAINER_PLAN_NAME: ' EXISTING_AZURE_CONTAINER_PLAN_NAME
  echo "$azureBlobContainerNamePrompt"
  read -p 'AZURE_BLOB_CONTAINER_NAME: ' AZURE_BLOB_CONTAINER_NAME
  echo "$azureBlobAccountNamePrompt"
  read -p 'AZURE_BLOB_ACCOUNT_NAME: ' AZURE_BLOB_ACCOUNT_NAME
  echo "$azureBlobAccountKeyPrompt"
  read -sp 'AZURE_BLOB_ACCOUNT_KEY: ' AZURE_BLOB_ACCOUNT_KEY
  echo
  echo "$azureBlobDedicatedPrompt"
  select opt in "${azureBlobDedicatedOptions[@]}"; do
    case "$REPLY" in
    1)
      echo "You picked $opt."
      #can be shared = no
      EXISTING_AZURE_CONTAINER_PLAN_TYPE=dedicated
      AZURE_PORTAL_PLAN_TYPE=Dedicated
      break
      ;;
    2)
      echo "You picked $opt."
      #can be shared = yes
      EXISTING_AZURE_CONTAINER_PLAN_TYPE=on-demand
      AZURE_PORTAL_PLAN_TYPE=OnDemand
      break
      ;;
    *)
      echo "Invalid option. Try another one."
      continue
      ;;
    esac
  done

  cat <<EOF | $kubectl_apply_eof

apiVersion: privatecloud.mendix.com/v1alpha1
kind: StoragePlan
metadata:
    name: "${EXISTING_AZURE_CONTAINER_PLAN_NAME}"
    labels:
        privatecloud.mendix.com/storage-type: file
        privatecloud.mendix.com/storage-class: ""
        privatecloud.mendix.com/storage-plan: "${EXISTING_AZURE_CONTAINER_PLAN_NAME}"
spec:
    type: ${EXISTING_AZURE_CONTAINER_PLAN_TYPE}
    create:
        args: [ "--from-secret" ]
        image: ${PROVISIONER_REPOSITORY}:basic-rhel
        resources:
            requests:
                memory: "64Mi"
                cpu: "100m"
            limits:
                memory: "64Mi"
                cpu: "500m"
        command: ["create"]
        credentialsSecretName: mendix-storage-${EXISTING_AZURE_CONTAINER_PLAN_NAME}-secret
        serviceAccountName: mendix-storage-provisioner
        instanceNameTemplate: "mendix-{{.Name}}-{{.UUID}}"
    delete:
        image: ${PROVISIONER_REPOSITORY}:basic-rhel
        resources:
            requests:
                memory: "64Mi"
                cpu: "100m"
            limits:
                memory: "64Mi"
                cpu: "500m"
        command: ["delete"]
        credentialsSecretName: mendix-storage-${EXISTING_AZURE_CONTAINER_PLAN_NAME}-secret

EOF

  #secret
  cat <<EOF | $kubectl_apply_eof
apiVersion: v1
kind: Secret
metadata:
  name: mendix-storage-${EXISTING_AZURE_CONTAINER_PLAN_NAME}-secret
type: Opaque
stringData:
    config: |-
      {
        "com.mendix.core.StorageService":"com.mendix.storage.azure",
        "com.mendix.storage.azure.AccountName": "$AZURE_BLOB_ACCOUNT_NAME",
        "com.mendix.storage.azure.AccountKey": "$AZURE_BLOB_ACCOUNT_KEY",
        "com.mendix.storage.azure.Container": "$AZURE_BLOB_CONTAINER_NAME",
        "com.mendix.storage.azure.UseHttps": true
      }
EOF

  #remove annotation
  $kubectl_annotate secret mendix-storage-${EXISTING_AZURE_CONTAINER_PLAN_NAME}-secret kubectl.kubernetes.io/last-applied-configuration-

  addPlanToPortal "storage" ${EXISTING_AZURE_CONTAINER_PLAN_NAME} ${AZURE_PORTAL_PLAN_TYPE}
}

# function to configure the Ephemeral storage
ephemeralStorageConfig() {
  cat <<EOF | $kubectl_apply_eof

apiVersion: privatecloud.mendix.com/v1alpha1
kind: StoragePlan
metadata:
  name: file-ephemeral
  labels:
    privatecloud.mendix.com/storage-type: file
    privatecloud.mendix.com/storage-class: ""
    privatecloud.mendix.com/storage-plan: ephemeral
spec:
  type: on-demand
  create:
    image: ${PROVISIONER_REPOSITORY}:basic-rhel
    resources:
      requests:
        memory: "64Mi"
        cpu: "100m"
      limits:
        memory: "64Mi"
        cpu: "500m"
    command: ["create"]
    args: ["--from-value={}"]
    serviceAccountName: mendix-storage-provisioner
    instanceNameTemplate: "mendix-{{.Name}}-{{.UUID}}"
  delete:
    image: ${PROVISIONER_REPOSITORY}:basic-rhel
    resources:
      requests:
        memory: "64Mi"
        cpu: "100m"
      limits:
        memory: "64Mi"
        cpu: "500m"
    command: ["delete"]
    args: []

EOF

  addPlanToPortal "storage" "ephemeral" "OnDemand"
}

# function to configure the OpenShift Route
openshiftRouteConfig() {
  osRouteTlsPrompt="Do you want to have TLS enabled? "
  osRouteTlsOptions=("Yes" "No")

  echo
  echo "$osRouteTlsPrompt"
  select opt in "${osRouteTlsOptions[@]}" "Go back to the start"; do
    case "$REPLY" in
    1)
      echo "You picked $opt."
      #yes
      OS_ROUTE_TLS=true
      break
      ;;
    2)
      echo "You picked $opt."
      #no
      OS_ROUTE_TLS=false
      break
      ;;

    3)
      scriptStart
      break
      ;;
    *)
      echo "Invalid option. Try another one."
      continue
      ;;
    esac
  done

  OS_ROUTE_PATCH=$(
cat <<EOF
{
  "spec": {
    "endpoint": {
      "type": "openshiftRoute",
      "ingress": null,
      "openshiftRoute": {
        "enableTLS": ${OS_ROUTE_TLS}
      }
    }
  }
}
EOF
  )

  $kubectl_patch operatorconfiguration mendix-operator-configuration --type=merge -p "${OS_ROUTE_PATCH}"
}

# function to configure the Ingress
ingressConfig() {
  ingressTlsPrompt="Do you want to have TLS enabled? "
  ingressTlsOptions=("Yes" "No")
  ingressDomainPrompt="What's the domain name of the Ingress?"

  echo
  echo "$ingressDomainPrompt"
  read -p 'INGRESS_DOMAIN: ' INGRESS_DOMAIN

  echo "$ingressTlsPrompt"
  select opt in "${ingressTlsOptions[@]}" "Go back to the start"; do
    case "$REPLY" in
    1)
      echo "You picked $opt."
      #yes
      INGRESS_TLS=true
      break
      ;;
    2)
      echo "You picked $opt."
      #no
      INGRESS_TLS=false
      break
      ;;
    3)
      scriptStart
      break
      ;;
    *)
      echo "Invalid option. Try another one."
      continue
      ;;
    esac
  done

  INGRESS_PATCH=$(
cat <<EOF
{
  "spec": {
    "endpoint": {
      "type": "ingress",
      "ingress": {
        "domain": "${INGRESS_DOMAIN}",
        "enableTLS": $INGRESS_TLS,
        "annotations": {"nginx.ingress.kubernetes.io/proxy-body-size": "500m"}
      },
      "openshiftRoute": null
    }
  }
}
EOF
  )

  $kubectl_patch operatorconfiguration mendix-operator-configuration --type=merge -p "${INGRESS_PATCH}"
}

# function to select the type of script you want to run
scriptStart() {
  scriptStartPrompt="What do you want to do?"
  scriptStartOptions=("Initial configuration" "Configure your operator")

  echo
  echo "$scriptStartPrompt"
  select opt in "${scriptStartOptions[@]}"; do
    case "$REPLY" in
    1)
      echo -e "You picked $opt."
      #initial installation
      initialInstallation
      break
      ;;
    2)
      echo "You picked $opt."
      #configuration
      resourceSelection
      break
      ;;
    *)
      echo "Invalid option. Try another one."
      continue
      ;;
    esac
  done
}

resourceSelection() {
  clusterTypePrompt="What do you want to configure?"
  clusterTypeOptions=("Database" "Storage" "Ingress" "Registry" "Proxy")

  echo
  echo "$clusterTypePrompt"
  select opt in "${clusterTypeOptions[@]}" "Go back to the start"; do
    case "$REPLY" in
    1)
      echo -e "You picked $opt."
      #database
      databaseTypeSelection
      break
      ;;
    2)
      echo "You picked $opt."
      #storage
      storageTypeSelection
      break
      ;;
    3)
      echo "You picked $opt."
      #ingress
      ingressTypeSelection
      break
      ;;
    4)
      echo "You picked $opt."
      #registry
      registryTypeSelection
      break
      ;;
    5)
      echo "You picked $opt."
      #proxy
      proxyConfiguration
      break
      ;;
    6)
      scriptStart
      break
      ;;
    *)
      echo "Invalid option. Try another one."
      continue
      ;;
    esac
  done
}

# function to select the database type
databaseTypeSelection() {
  databaseTypePrompt="Pick a database type: "
  databaseTypeOptions=("Postgres" "Ephemeral" "SQL Server" "Dedicated JDBC")

  echo
  echo "$databaseTypePrompt"
  select opt in "${databaseTypeOptions[@]}" "Go back to the start"; do
    case "$REPLY" in
    1)
      echo "You picked $opt."
      #postrgresql
      postgresConfig
      break
      ;;
    2)
      echo "You picked $opt."
      #ephemeral doesn't need any additional configuration
      ephemeralDatabaseConfig
      break
      ;;
    3)
      echo "You picked $opt."
      #sqlserver
      sqlserverConfig
      break
      ;;
    4)
      echo "You picked $opt."
      #dedicatedJDBC
      dedicatedJDBCConfig
      break
      ;;
	5)
      scriptStart
      break
      ;;
    *)
      echo "Invalid option. Try another one."
      continue
      ;;
    esac
  done
}

# function to select the type of storage
storageTypeSelection() {
  storageTypePrompt="Pick a storage type: "
  storageTypeOptions=("Minio" "Ephemeral" "S3 (create on-demand)" "S3 (existing bucket)" "Azure Blob storage Container (existing)")

  echo
  echo "$storageTypePrompt"
  select opt in "${storageTypeOptions[@]}" "Go back to the start"; do
    case "$REPLY" in
    1)
      echo "You picked $opt."
      #minio
      minioConfig
      break
      ;;
    2)
      echo "You picked $opt."
      #ephemeral doesn't need any additional configuration
      ephemeralStorageConfig
      break
      ;;
    3)
      echo "You picked $opt."
      s3Config
      break
      ;;
    4)
      echo "You picked $opt."
      existingS3Config
      break
      ;;
    5)
      echo "You picked $opt."
      azureBlobContainerConfig
      break
      ;;
    6)
      scriptStart
      break
      ;;
    *)
      echo "Invalid option. Try another one."
      continue
      ;;
    esac
  done
}

# function to select the type of ingress
ingressTypeSelection() {
  ingressTypePrompt="Pick an ingress type: "
  ingressTypeOptions=("OpenShift Route" "Ingress")

  echo
  echo "$ingressTypePrompt"
  select opt in "${ingressTypeOptions[@]}" "Go back to the start"; do
    case "$REPLY" in
    1)
      echo "You picked $opt."
      #openshift route
      openshiftRouteConfig
      break
      ;;
    2)
      echo "You picked $opt."
      #ingress
      ingressConfig
      break
      ;;
    3)
      scriptStart
      break
      ;;
    *)
      echo "Invalid option. Try another one."
      continue
      ;;
    esac
  done
}

# function to select the type of registry
registryTypeSelection() {
  registryTypePrompt="Pick a registry type: "
  registryTypeOptions=("OpenShift 3 Registry" "OpenShift 4 Registry" "Amazon Elastic Container Registry" "Generic registry with authentication" "Generic registry without authentication" "Existing docker-registry secret")

  echo
  echo "$registryTypePrompt"
  select opt in "${registryTypeOptions[@]}" "Go back to the start"; do
    case "$REPLY" in
    1)
      echo "You picked $opt."
      #openshift3
      openshift3RegistryConfig
      break
      ;;
    2)
      echo "You picked $opt."
      #openshift4
      openshift4RegistryConfig
      break
      ;;
    3)
      echo "You picked $opt."
      #aws ecr
      awsECRConfig
      break
      ;;
    4)
      echo "You picked $opt."
      #generic with authentication
      genericRegistryAuthConfig
      break
      ;;
    5)
      echo "You picked $opt."
      #generic without authentication
      genericRegistryNoAuthConfig
      break
      ;;
    6)
      echo "You picked $opt."
      #Existing docker-registry secret
      existingDockerConfig
      break
      ;;
    7)
      scriptStart
      break
      ;;
    *)
      echo "Invalid option. Try another one."
      continue
      ;;
    esac
  done

}

# function to enable proxy
enableProxy() {
  httpProxyURLPrompt="What's the HTTP URL of your proxy?"
  httpsProxyURLPrompt="What's the HTTPS URL of your proxy?"
  noProxyPrompt="What's the NO_PROXY environment variable? (NO_PROXY environment variable contains comma-separated values specifying hosts that should be excluded from proxying"
  echo
  echo "$httpProxyURLPrompt"
  read -p 'HTTP_PROXY: ' HTTP_PROXY
  echo "$httpsProxyURLPrompt"
  read -p 'HTTPS_PROXY: ' HTTPS_PROXY
  echo "$noProxyPrompt"
  read -p 'NO_PROXY: ' NO_PROXY

  #secret
  cat <<EOF | $kubectl_apply_eof
apiVersion: v1
kind: Secret
metadata:
  name: mendix-proxy
type: Opaque
stringData:
    http_proxy: "${HTTP_PROXY}"
    https_proxy: "${HTTPS_PROXY}"
    no_proxy: "${NO_PROXY}"
EOF

  #remove annotation
  $kubectl_annotate secret mendix-proxy kubectl.kubernetes.io/last-applied-configuration-

  $kubectl_patch deployment mendix-agent --patch \
  '{
  "spec":{
    "template":{
      "spec":{
        "containers":[
          {
            "name":"mendix-agent",
            "env":[
              {
                "name":"http_proxy",
                "valueFrom":{
                  "secretKeyRef":{
                    "name":"mendix-proxy",
                    "key":"http_proxy"
                  }
                }
              },
              {
                "name":"https_proxy",
                "valueFrom":{
                  "secretKeyRef":{
                    "name":"mendix-proxy",
                    "key":"https_proxy"
                  }
                }
              },
              {
                "name":"no_proxy",
                "valueFrom":{
                  "secretKeyRef":{
                    "name":"mendix-proxy",
                    "key":"no_proxy"
                  }
                }
              }
            ]
          }
        ]
      }
    }
  }
}'

  $kubectl_patch operatorconfiguration mendix-operator-configuration --type=merge -p '{"spec": {"buildProxySecretName": "mendix-proxy"}}'
}

# function to disable proxy
disableProxy() {

  $kubectl_delete secret mendix-proxy
  $kubectl_patch operatorconfiguration mendix-operator-configuration --type=merge -p '{"spec": {"buildProxySecretName": null}}'

  $kubectl_set env deployment/mendix-agent http_proxy-
  $kubectl_set env deployment/mendix-agent https_proxy-
  $kubectl_set env deployment/mendix-agent no_proxy-

}

# function to set up the proxy
proxyConfiguration() {
  proxyConfigPrompt="Do you want to enable or disable the proxy?"
  proxyConfigOptions=("Enable" "Disable")

  echo
  echo "$proxyConfigPrompt"
  select opt in "${proxyConfigOptions[@]}"; do
    case "$REPLY" in
    1)
      echo -e "You picked $opt."
      #enable
      enableProxy
      break
      ;;
    2)
      echo "You picked $opt."
      #disable
      disableProxy
      break
      ;;
    *)
      echo "Invalid option. Try another one."
      continue
      ;;
    esac
  done

}

# function to start setting up the proxy
proxyStartConfiguration() {
  proxyStartPrompt="Do you want to configure the proxy?"
  proxyStartOptions=("Yes" "No")

  echo
  echo "$proxyStartPrompt"
  select opt in "${proxyStartOptions[@]}"; do
    case "$REPLY" in
    1)
      echo -e "You picked $opt."
      #yes
      proxyConfiguration
      break
      ;;
    2)
      echo "You picked $opt."
      #no
      break
      ;;
    *)
      echo "Invalid option. Try another one."
      continue
      ;;
    esac
  done

}

# function for initial installation
initialInstallation() {
  databaseTypeSelection
  storageTypeSelection
  ingressTypeSelection
  registryTypeSelection
  proxyStartConfiguration
}

# the script starts here
scriptStart

